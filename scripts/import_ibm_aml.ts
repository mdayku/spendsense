import fs from "node:fs";
import path from "node:path";
import { parse } from "csv-parse";
import dayjs from "dayjs";
import { PrismaClient } from "@prisma/client";
const prisma = new PrismaClient();
const DATA_DIR = path.join(process.cwd(), "data", "ibm_aml");
const H = { txId:["transaction_id","tx_id","id"], ts:["timestamp","datetime","date","time"], src:["originator","src","payer","from","source","sender"], dst:["beneficiary","dst","payee","to","destination","receiver"], amount:["amount","amt","value"], currency:["currency","ccy"], laundering:["is_laundering","laundering","label","is_sar","is_illicit"] } as const;

type HeaderMap = Record<keyof typeof H, string>;
function resolveHeaders(headers: string[]): HeaderMap { const lower = headers.map(h=>h.toLowerCase()); const map = {} as HeaderMap; (Object.keys(H) as (keyof typeof H)[]).forEach(k=>{ const found = H[k].map(x=>x.toLowerCase()).find(n=>lower.includes(n)); if(!found) throw new Error(`Missing required column for ${k}. Headers: ${headers.join(", ")}`); map[k] = headers[lower.indexOf(found)]; }); return map; }
async function ensureUserForEntity(entityId: string) { const email = `${entityId}@aml.local`; let u = await prisma.user.findUnique({ where: { email } }); if(!u){ u = await prisma.user.create({ data: { name: `Entity ${entityId}`, email } }); await prisma.consent.create({ data: { userId: u.id, status: "OPTED_IN" } }); await prisma.account.create({ data: { userId: u.id, type: "checking", subtype: "checking", numberMasked: `****${entityId.slice(-4)}`, isoCurrencyCode: "USD", balanceCurrent: 0 } }); await prisma.account.create({ data: { userId: u.id, type: "credit", subtype: "card", numberMasked: `****${Math.random().toString().slice(2,6)}`, isoCurrencyCode: "USD", balanceCurrent: 0, creditLimit: 5000 } }); } return u; }
async function importFile(filePath: string, limit = Number(process.env.IMPORT_LIMIT || 0)) { console.log(`Importing ${path.basename(filePath)} ...`); const parser = fs.createReadStream(filePath).pipe(parse({ columns: true })); let headers: string[] | null = null; let map: HeaderMap | null = null; let n=0; for await (const row of parser) { if(!headers){ headers = Object.keys(row); map = resolveHeaders(headers); console.log("Detected headers:", map); } n++; if(limit && n>limit) break; const srcEntity=String(row![map!.src]); const dstEntity=String(row![map!.dst]); const ts=row![map!.ts]; const amount=Number(row![map!.amount]); const extTxId=String(row![map!.txId]||""); const launderingRaw=row![map!.laundering]; const laundering = launderingRaw!==undefined && String(launderingRaw).toLowerCase()!=='false' && launderingRaw!=="0"; await importAsSpend(srcEntity,dstEntity,ts,amount,extTxId,laundering); } console.log(`Done ${path.basename(filePath)} rows=${n}`); }
async function importAsSpend(srcEntity:string,dstEntity:string,ts:string,amount:number,extTxId:string, laundering:boolean){ const srcUser=await ensureUserForEntity(srcEntity); const acct=await prisma.account.findFirst({ where:{ userId: srcUser.id, type:"checking" }}); const date=dayjs(ts).isValid()?dayjs(ts).toDate():new Date(); await prisma.transaction.create({ data: { userId: srcUser.id, accountId: acct!.id, date, amount: -Math.abs(amount), merchant: dstEntity, merchantEntityId: dstEntity, paymentChannel: "online", pfcPrimary: "transfer" }}); await prisma.account.update({ where: { id: acct!.id }, data: { balanceCurrent: { decrement: Math.abs(amount) } } }); await prisma.amlLabel.create({ data: { userId: srcUser.id, extTxId, label: laundering, amount: Math.abs(amount), counterparty: dstEntity, date } }); }
async function main(){ if(!fs.existsSync(DATA_DIR)){ console.error(`Missing data dir: ${DATA_DIR}`); process.exit(1);} const files = fs.readdirSync(DATA_DIR).filter(f=>f.endsWith(".csv")); if(!files.length){ console.error("No CSV files found in data/ibm_aml"); process.exit(1);} for(const f of files) await importFile(path.join(DATA_DIR,f)); console.log("Import complete."); }
main().finally(()=>prisma.$disconnect());

